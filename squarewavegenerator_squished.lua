#!/usr/bin/lua5.2
local a=require("bit32")local b=require("io")local c=require("math")local d=require("os")local e=require("string")local f=-(0/0)local g=1/0;local h={C=0,D=2,E=4,F=5,G=7,A=9,B=11}local function i(j)if tostring(j)=="0"then return e.char(0x00,0x00,0x00,0x00)elseif tostring(j)=="-0"then return e.char(0x80,0x00,0x00,0x00)elseif j==g then return e.char(0x7f,0x80,0x00,0x00)elseif j==-g then return e.char(0xff,0x80,0x00,0x00)elseif j==f then return e.char(0x7f,0xff,0xff,0xff)elseif j==-f then return e.char(0xff,0xff,0xff,0xff)else local k=0;if j<0 then k=128 end;local l,m=c.frexp(c.abs(j))l=l*2^24;m=m+126;if m>255 then return e.char(a.bor(k,0x7f),0x80,0,0)elseif m<0 then return e.char(k,0x7f,0xff,0xff)end;return e.char(a.bor(k,a.band(a.rshift(m,1),0x7f)),a.bor(a.band(a.lshift(m,7),0x80),a.band(a.rshift(l,16),0x7f)),a.band(a.rshift(l,8),0xff),a.band(l,0xff))end end;local function n(j)if j<-1 then j=-1 end;if j>=1 then j=32767/32768 end;if j<0 then j=j+2 end;j=c.floor(j*32768)return e.char(a.rshift(j,8),a.band(j,0xff))end;local function o(p,q,r,s,t,u)local v=p((q-r)/(s-r))return(1-v)*t+v*u end;local w={...}local x=1;local y,z,A,B,C,D,E,F,G;local H={}local I=""local J=0;while x<=#w do if w[x]=="outputfile"or w[x]=="output"or w[x]=="of"then y=w[x+1]x=x+1 elseif w[x]=="mplayer"or w[x]=="play"then y=true elseif w[x]=="mplayeroptions"then I=I.." "..w[x+1]x=x+1 elseif w[x]=="quiet"or w[x]=="q"then z=true elseif w[x]=="noprogress"or w[x]=="np"then B=true elseif w[x]=="nointeractive"or w[x]=="ni"then A=true elseif w[x]=="samplerate"or w[x]=="sr"then C=tonumber(w[x+1])x=x+1 elseif w[x]=="gain"or w[x]=="g"then D=tonumber(w[x+1])x=x+1 elseif w[x]=="endian"then if w[x+1]=="little"then E=e.reverse elseif w[x+1]=="big"then E=function(K)return K end end;x=x+1 elseif w[x]=="pcm"then F=true elseif w[x]=="wave"or w[x]=="w"then local j=tonumber(w[x+1])if not j or j~=c.floor(j)or j<0 then b.stderr:write("error at argument #"..x+1 ..": whole number expected\n")d.exit(-1)end;if not H[j]then H[j]={}end;local L=w[x+2]local M=w[x+3]local N=tonumber(M)local O=false;if L=="starttime"or L=="start"then if M:sub(-1,-1)=="s"then H[j].starttime=tonumber(M:sub(1,-2))*(C or 44100)if not H[j].starttime then O=true end else H[j].starttime=N;O=true end elseif L=="endtime"or L=="end"then if M:sub(-1,-1)=="s"then H[j].endtime=tonumber(M:sub(1,-2))*(C or 44100)if not H[j].endtime then O=true end else H[j].endtime=N;if N then if J then if N>J then J=N end else J=N end end;O=true end elseif L=="volumestart"or L=="vol"or L=="volstart"then H[j].volumestart=N;O=true elseif L=="volumeend"or L=="volend"then H[j].volumeend=N;O=true elseif L=="volumeramp"or L=="volramp"then H[j].volumeramp=load("return function(x) return "..M.." end","volumeramp","t",c)or function()b.stderr:write("error at argument #"..x+3 ..": invalid function\n")d.exit(-1)end()elseif L=="shape"then if M~="sine"and M~="square"and M~="sawtooth"and M~="triangle"and M~="noise"then b.stderr:write("error at argument #"..x+2 .." ("..(w[x+2]or"<none>")..": illegal wave shape\n")d.exit(-1)end;H[j].shape=M elseif L=="frequencystart"or L=="freq"or L=="freqstart"then H[j].frequencystart=M elseif L=="frequencyend"or L=="freqend"then H[j].frequencyend=M elseif L=="frequencyramp"or L=="freqramp"then H[j].frequencyramp=M elseif L=="dutystart"or L=="duty"then H[j].dutystart=N;O=true elseif L=="dutyend"then H[j].dutyend=N;O=true elseif L=="dutyramp"then H[j].dutyramp=load("return function(x) return "..M.." end","volumeramp","t",c)or function()b.stderr:write("error at argument #"..x+3 ..": invalid function\n")d.exit(-1)end()else b.stderr:write("error at argument #"..x+1 .." ("..(w[x+1]or"<none>").."): illegal property name\n")d.exit(-1)end;if O and not N then b.stderr:write("error at argument #"..x+3 .." ("..(w[x+3]or"<none>").."): illegal number\n")d.exit(-1)end;x=x+3 else b.stderr:write("error at argument #"..x.." ("..(w[x]or"<none>").."): illegal option\n")d.exit(-1)end;x=x+1 end;local P=0;for x,v in pairs(H)do if x>P then P=x end end;if y and not(y==true)then y,reason=b.open(y,"wb")if not y then b.stderr:write("error opening file for writing: "..reason.."\n")d.exit(-1)end;y:setvbuf("full")elseif not(y==true)then y=b.stdout;if not z then b.stderr:write("warning: output will be to stdout\n")end else F=true;E=e.reverse;if not z then b.stderr:write("warning: output will be played to mplayer\n")end end;if A then C=C or 44100;D=D or 1;E=E or e.reverse;F=F or false else if not C then if not z then b.stderr:write("sample rate (number samples/second) [44100]: ")end;C=tonumber(b.read())or 44100 end;if not D then if not z then b.stderr:write("gain (number 0 to 1) [1]: ")end;D=tonumber(b.read())or 1 end;if not E then if not z then b.stderr:write("little/big endian [little/big] [little]: ")end;E=e.reverse;if b.read():lower()=="big"then function E(Q)return Q end end end;if not F then if not z then b.stderr:write("32-bit float or 16-bit pcm [float/pcm] [float]: ")end;F=b.read()if F=="pcm"then F=true end end end;local R=0;if not A then if not z then b.stderr:write("number of wave events (whole number) [1]: ")end;R=tonumber(b.read())or 1 end;for x=1,R+P do local S=false;if x<=P and H[x]then S=true end;if x<=P and not H[x]then else if not S then H[x]={}end;if not S and not z then b.stderr:write("wave #"..x-P.."\nstarting time (number samples) [1]: ")end;if S then H[x].starttime=H[x].starttime or 1 else local T=b.read()if T:sub(-1,-1)=="s"then H[x].starttime=tonumber(T:sub(1,-2))*C else H[x].starttime=tonumber(T)end;H[x].starttime=H[x].starttime or 1 end;if not S and not z then b.stderr:write("ending time (number samples) ["..(J>0 and J or H[x].starttime+C-1).."]: ")end;if S then H[x].endtime=H[x].endtime or J>0 and J or H[x].starttime+C-1 else local T=b.read()if T:sub(-1,-1)=="s"then H[x].endtime=tonumber(T:sub(1,-2))*C else H[x].endtime=tonumber(T)end;H[x].endtime=H[x].endtime or J>0 and J or H[x].starttime+C-1 end;if H[x].endtime>J then J=H[x].endtime end;if not S and not z then b.stderr:write("volume at start (number -1 to 1) [1]: ")end;H[x].volumestart=S and(H[x].volumestart or 1)or tonumber(b.read())or 1;if not S and not z then b.stderr:write("volume at end (number -1 to 1) ["..H[x].volumestart.."]: ")end;H[x].volumeend=S and(H[x].volumeend or H[x].volumestart)or tonumber(b.read())or H[x].volumestart;if H[x].volumestart~=H[x].volumeend then if not S and not z then b.stderr:write("volume ramp [f(x)=x]: f(x)=")end;local p;if not S then p=b.read()if p==""then p="x"end;H[x].volumeramp=load("return function(x) return "..p.." end","volumeramp","t",c)()elseif not H[x].volumeramp then H[x].volumeramp=function(U)return U end end else H[x].volumeramp=function()return 0 end end;if not S then if not z then b.stderr:write("wave shape [sine/square/sawtooth/triangle/noise] [sine]: ")end;H[x].shape=b.read()end;if not(H[x].shape=="sine"or H[x].shape=="square"or H[x].shape=="sawtooth"or H[x].shape=="triangle"or H[x].shape=="noise")then if not z and shape then b.stderr:write("illegal wave shape \""..H[x].shape.."\", selecting default \"sine\"\n")end;H[x].shape="sine"end;if H[x].shape~="noise"then if not S and not z then b.stderr:write("frequency at start (number Hz or MIDI name) [440]: ")end;H[x].frequencystart=S and(H[x].frequencystart or 440)or b.read()if H[x].frequencystart==""then H[x].frequencystart=440 end;if not tonumber(H[x].frequencystart)then local V=H[x].frequencystart;local W=h[V:sub(1,1):upper()]or h.A;local X=tonumber(V:match("%d+$"))or 4;for x=2,V:len()do if V:sub(x,x)=="#"then W=W+1 end;if V:sub(x,x)=="b"then W=W-1 end end;H[x].frequencystart=440*2^((W-69)/12+X+1)else H[x].frequencystart=tonumber(H[x].frequencystart)end;if not S and not z then b.stderr:write("frequency at end (number Hz or MIDI name) ["..H[x].frequencystart.."]: ")end;H[x].frequencyend=S and(H[x].frequencyend or H[x].frequencystart)or b.read()if H[x].frequencyend==""then H[x].frequencyend=H[x].frequencystart end;if not tonumber(H[x].frequencyend)then local V=H[x].frequencyend;local W=h[V:sub(1,1):upper()]or h.A;local X=tonumber(V:match("%d+$"))or 4;for x=2,V:len()do if V:sub(x,x)=="#"then W=W+1 end;if V:sub(x,x)=="b"then W=W-1 end end;H[x].frequencyend=440*2^((W-69)/12+X+1)else H[x].frequencyend=tonumber(H[x].frequencyend)end;if H[x].frequencystart~=H[x].frequencyend then local p;if not S then if not z then b.stderr:write("frequency ramp [f(x)=x]: f(x)=")end;p=b.read()else p=H[x].frequencyramp or"lin"end;if p==""or not p then p="lin"end;if p=="lin"then H[x].frequencyramp=function(U)return U end elseif p=="exp"then local Y=c.exp(1)local Z=c.log(Y-1)H[x].frequencyramp=function(U)return c.exp(U-Z)-1/(Y-1)end else H[x].frequencyramp=load("return function(x) return "..p.." end","frequencyramp","t",c)()end else H[x].frequencyramp=function()return 0 end end else H[x].frequencystart=0;H[x].frequencyend=0;H[x].frequencyramp=function(U)return U end end;if H[x].shape=="square"then if not S and not z then b.stderr:write("duty cycle at start (number 0 to 1) [.5]: ")end;H[x].dutystart=S and(H[x].dutystart or.5)or tonumber(b.read())or.5;if not S and not z then b.stderr:write("duty cycle at end (number 0 to 1) ["..H[x].dutystart.."]: ")end;H[x].dutyend=S and(H[x].dutyend or H[x].dutystart)or tonumber(b.read())or H[x].dutystart;if H[x].dutystart~=H[x].dutyend then if not S then if not z then b.stderr:write("duty ramp [f(x)=x]: f(x)=")end;local p=b.read()if p==""then p="x"end;H[x].dutyramp=load("return function(x) return "..p.." end","dutyramp","t",c)()elseif not H[x].dutyramp then H[x].dutyramp=function(U)return U end end else H[x].dutyramp=function()return 0 end end end;H[x].totaltime=H[x].endtime-H[x].starttime+1 end end;if y==true then y,reason=b.popen("mplayer -demuxer rawaudio -rawaudio channels=1:rate="..C..":samplesize=2 -really-quiet"..I.." -","w")if not y then b.stderr:write("error opening mplayer pipe: "..reason.."\n")d.exit(-1)end end;if not z then b.stderr:write("total file size is "..J.." samples or "..J*(F and 2 or 4).." bytes or "..J*(F and 2 or 4)/1048576 .." megabytes\n")end;for x=1,J do if not B and x%C==0 then b.stderr:write("\rsample "..x.."/"..J.." ("..c.floor(x/J*100).."%)")end;local _=0;for a0=1,R+P do if H[a0]and H[a0].starttime<=x and H[a0].endtime>=x then if H[a0].previousvalue and(c.abs(H[a0].previousvalue)==f or c.abs(H[a0].previousvalue)==g)then H[a0].previousvalue=nil end;local a1=o(H[a0].volumeramp,x,H[a0].starttime,H[a0].endtime,H[a0].volumestart,H[a0].volumeend)local a2=H[a0].frequencyramp and o(H[a0].frequencyramp,x,H[a0].starttime,H[a0].endtime,H[a0].frequencystart,H[a0].frequencyend)or H[a0].frequencystart;local a3=H[a0].dutyramp and o(H[a0].dutyramp,x,H[a0].starttime,H[a0].endtime,H[a0].dutystart,H[a0].dutyend)or H[a0].dutystart;local a4=a2 and(H[a0].previousvalue and a2/C+H[a0].previousvalue or(x-H[a0].starttime)*a2/C)%1;H[a0].previousvalue=a4;if H[a0].shape=="noise"then _=_+(c.random()*2-1)*a1 elseif H[a0].shape=="sine"then _=_+c.sin(a4*2*c.pi)*a1 elseif H[a0].shape=="square"then _=_+(a4<a3 and 1 or-1)*a1 elseif H[a0].shape=="sawtooth"then _=_+(1-a4*2)*a1 elseif H[a0].shape=="triangle"then _=_+(a4<.25 and a4 or a4>.75 and a4-1 or.5-a4)*4 end end end;y:write(E(F and n or i(_*D)))end;y:flush()y:close()if not B then b.stderr:write("\n")end
